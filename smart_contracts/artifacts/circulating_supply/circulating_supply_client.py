# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": ["NoOp"]}, "methods": [{"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The ASA ID to initialize the circulating supply configuration for", "name": "asset"}, {"type": "pay", "desc": "Circulating supply configuration MBR payment transaction", "name": "mbr_payment"}], "name": "init_config", "returns": {"type": "uint64", "desc": "MBR (in microALGO) for the circulating supply configuration initialization"}, "desc": "Non-normative: Initialize the circulating supply configuration for an ASA\nAuthorization: ASA Manager Address.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "ASA ID of the circulating supply", "name": "asset"}, {"type": "address", "desc": "Address to assign to the non-circulating supply label to", "name": "address"}, {"type": "string", "desc": "Not-circulating supply label selector", "name": "label"}], "name": "set_not_circulating_address", "returns": {"type": "void"}, "desc": "Non-normative: Set non-circulating supply addresses\nAuthorization: ASA Manager Address.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The ASA ID to delete the circulating supply configuration for", "name": "asset"}], "name": "delete_config", "returns": {"type": "uint64", "desc": "MBR (in microALGO) for the circulating supply configuration deletion"}, "desc": "Non-normative: Delete the circulating supply configuration for an ASA\nAuthorization: ASA Manager Address.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The ASA ID to get the circulating supply configuration for", "name": "asset"}], "name": "get_config", "returns": {"type": "(address,address,address)", "desc": "ASA circulating supply configuration", "struct": "CirculatingSupplyConfig"}, "desc": "Non-normative: Get ASA circulating supply configuration.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "ASA ID of the circulating supply", "name": "asset_id"}], "name": "arc62_get_circulating_supply", "returns": {"type": "uint64", "desc": "ASA circulating supply"}, "desc": "Get ASA circulating supply.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "extra_resources", "returns": {"type": "void"}, "desc": "Non-normative: Placeholder method to acquire AVM extra resources.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "withdraw_balance_excess", "returns": {"type": "void"}, "desc": "Non-normative: Method to withdraw balance excess due to accidental deposits\n(it should never happen if deposits match exactly the required MBR. Deleted config MBR is not included in the excess, since it is immediately returned on delete).", "events": [], "readonly": false, "recommendations": {}}], "name": "CirculatingSupply", "state": {"keys": {"box": {}, "global": {}, "local": {}}, "maps": {"box": {"circulating_supply": {"keyType": "uint64", "valueType": "CirculatingSupplyConfig", "prefix": ""}}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 0, "ints": 0}, "local": {"bytes": 0, "ints": 0}}}, "structs": {"CirculatingSupplyConfig": [{"name": "burned_addr", "type": "address"}, {"name": "locked_addr", "type": "address"}, {"name": "custom_addr", "type": "address"}]}, "byteCode": {"approval": "CyAEAQAIICYBBBUffHUxG0EAQjEZFEQxGESCBwQI3u5+BKg/KYkETLbT3ASjR5XMBFzCxTUEAFbZwQS5LiZ6NhoAjgcACwBwAOoBMwFKAAECNAAiQzEZFDEYFBBDNhoBSRUkEkQXMRYiCUk4ECISRDEASwJxB0QSREwWSb1FARRESwE4BzIKEkQyCnMBREsBgWC5SDIDSwIjTwK7MgNLAiVPArsyA08CgUBPArsyCnMBREwJTDgISwEPRBYoTFCwIkM2GgFJFSQSRBc2GgJJTgJJFSUSRDYaA0kjWYECCEsBFRJEVwIAMQBLA3EHRBJESwIWSU4EvUUBRExPAnAARQFEggMGYnVybmVkBmxvY2tlZAZjdXN0b21PA44DABEACQABAEmBQEsDuyJDSSVLA7tC//ZJI0sDu0L/7jYaAUkVJBJEF0cCFklOAr1FAURxC0UBQQAJMQBLAnEHRBJEMgpzAURLAbxIMgpzAUQJsTEASwGyCLIHIrIQI7IBsxYoTFCwIkM2GgFJFSQSRBcWSb1FAUS+SChMULAiQyNHAoAARwI2GgFJFSQSRBdHAhZJTgK9RQFESXELTgJIcQhEMgMSQAASSUEADksCSXEIRExwAEUBQACgI0UESwG+RFcAIElFCjIDEkAAD0lBAAtLCEsDcABFAUAAciNFBksBvkRXICBJRQgyAxJAAA9JQQALSwZLA3AARQFAAEQjRQVLAb5EV0AgSUUJMgMSQAAPSUEAC0sHSwNwAEUBQAAYI0sDcQBESwUJSwcJSwYJTAkWKExQsCJDSwdLA3AAREL/30sGSwNwAERFBUL/s0sISwNwAERFBkL/hUsCSXEIRExwAERFBEL/VDIKcwBEMgpzAUQJsTIJsgeyCCKyECOyAbMiQw==", "clear": "C4EBQw=="}, "desc": "\n    Singleton Application providing ARC-62 getter for ASA Circulating Supply\n    ", "events": [], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAxIDAgOCAzMgogICAgYnl0ZWNibG9jayAweDE1MWY3Yzc1CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjMwCiAgICAvLyBjbGFzcyBDaXJjdWxhdGluZ1N1cHBseShBcmM2MkludGVyZmFjZSk6CiAgICB0eG4gTnVtQXBwQXJncwogICAgYnogbWFpbl9fX2FsZ29weV9kZWZhdWx0X2NyZWF0ZUAxNgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0CiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0CiAgICBwdXNoYnl0ZXNzIDB4MDhkZWVlN2UgMHhhODNmMjk4OSAweDRjYjZkM2RjIDB4YTM0Nzk1Y2MgMHg1Y2MyYzUzNSAweDAwNTZkOWMxIDB4YjkyZTI2N2EgLy8gbWV0aG9kICJpbml0X2NvbmZpZyh1aW50NjQscGF5KXVpbnQ2NCIsIG1ldGhvZCAic2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzKHVpbnQ2NCxhZGRyZXNzLHN0cmluZyl2b2lkIiwgbWV0aG9kICJkZWxldGVfY29uZmlnKHVpbnQ2NCl1aW50NjQiLCBtZXRob2QgImdldF9jb25maWcodWludDY0KShhZGRyZXNzLGFkZHJlc3MsYWRkcmVzcykiLCBtZXRob2QgImFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHkodWludDY0KXVpbnQ2NCIsIG1ldGhvZCAiZXh0cmFfcmVzb3VyY2VzKCl2b2lkIiwgbWV0aG9kICJ3aXRoZHJhd19iYWxhbmNlX2V4Y2Vzcygpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIGluaXRfY29uZmlnIHNldF9ub3RfY2lyY3VsYXRpbmdfYWRkcmVzcyBkZWxldGVfY29uZmlnIGdldF9jb25maWcgYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseSBtYWluX2V4dHJhX3Jlc291cmNlc19yb3V0ZUAxMSB3aXRoZHJhd19iYWxhbmNlX2V4Y2VzcwogICAgZXJyCgptYWluX2V4dHJhX3Jlc291cmNlc19yb3V0ZUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MjA3CiAgICAvLyBAYWJpbWV0aG9kCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgptYWluX19fYWxnb3B5X2RlZmF1bHRfY3JlYXRlQDE2OgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgICYmCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuY2lyY3VsYXRpbmdfc3VwcGx5LmNvbnRyYWN0LkNpcmN1bGF0aW5nU3VwcGx5LmluaXRfY29uZmlnW3JvdXRpbmddKCkgLT4gdm9pZDoKaW5pdF9jb25maWc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjM4CiAgICAvLyBAYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18wIC8vIDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMCAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NTMKICAgIC8vIFR4bi5zZW5kZXIgPT0gYXNzZXQubWFuYWdlcgogICAgdHhuIFNlbmRlcgogICAgZGlnIDIKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRNYW5hZ2VyCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo1MS01NAogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBhc3NlcnQgKAogICAgLy8gICAgIFR4bi5zZW5kZXIgPT0gYXNzZXQubWFuYWdlcgogICAgLy8gKSwgZXJyLlVOQVVUSE9SSVpFRCAgIyBJbXBsaWNpdCBBU0EgZXhpc3RlbmNlIGNoZWNrCiAgICBhc3NlcnQgLy8gVW5hdXRob3JpemVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjU1CiAgICAvLyBhc3NlcnQgYXNzZXQgbm90IGluIHNlbGYuY2lyY3VsYXRpbmdfc3VwcGx5LCBlcnIuQ09ORklHX0VYSVNUUwogICAgc3dhcAogICAgaXRvYgogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgICEKICAgIGFzc2VydCAvLyBDaXJjdWxhdGluZyBzdXBwbHkgY29uZmlnIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIEFTQQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo1NwogICAgLy8gbWJyX3BheW1lbnQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZGlnIDEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NTYtNTgKICAgIC8vIGFzc2VydCAoCiAgICAvLyAgICAgbWJyX3BheW1lbnQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgLy8gKSwgZXJyLklOVkFMSURfTUJSX1JFQ0VJVkVSCiAgICBhc3NlcnQgLy8gSW52YWxpZCBjaXJjdWxhdGluZyBzdXBwbHkgY29uZmlnIE1CUiByZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo2MC02MQogICAgLy8gIyBJbml0aWFsaXplIEFTQSBDaXJjdWxhdGluZyBTdXBwbHkgQ29uZmlndXJhdGlvbgogICAgLy8gbWJyX2kgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NjItNjQKICAgIC8vIF9leGlzdHMgPSBzZWxmLmNpcmN1bGF0aW5nX3N1cHBseS5ib3goYXNzZXQpLmNyZWF0ZSgKICAgIC8vICAgICBzaXplPXNpemVfb2YoQ2lyY3VsYXRpbmdTdXBwbHlDb25maWcpCiAgICAvLyApCiAgICBkaWcgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo2MwogICAgLy8gc2l6ZT1zaXplX29mKENpcmN1bGF0aW5nU3VwcGx5Q29uZmlnKQogICAgcHVzaGludCA5NgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo2Mi02NAogICAgLy8gX2V4aXN0cyA9IHNlbGYuY2lyY3VsYXRpbmdfc3VwcGx5LmJveChhc3NldCkuY3JlYXRlKAogICAgLy8gICAgIHNpemU9c2l6ZV9vZihDaXJjdWxhdGluZ1N1cHBseUNvbmZpZykKICAgIC8vICkKICAgIGJveF9jcmVhdGUKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo2NQogICAgLy8gc2VsZi5jaXJjdWxhdGluZ19zdXBwbHlbYXNzZXRdLmJ1cm5lZF9hZGRyID0gR2xvYmFsLnplcm9fYWRkcmVzcwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICBkaWcgMgogICAgaW50Y18xIC8vIDAKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NjYKICAgIC8vIHNlbGYuY2lyY3VsYXRpbmdfc3VwcGx5W2Fzc2V0XS5sb2NrZWRfYWRkciA9IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgZGlnIDIKICAgIGludGNfMyAvLyAzMgogICAgdW5jb3ZlciAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo2NwogICAgLy8gc2VsZi5jaXJjdWxhdGluZ19zdXBwbHlbYXNzZXRdLmN1c3RvbV9hZGRyID0gR2xvYmFsLnplcm9fYWRkcmVzcwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgNjQKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NjktNzAKICAgIC8vICMgUG9zdGNvbmRpdGlvbnMKICAgIC8vIG1icl9kZWx0YV9hbW91bnQgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlIC0gbWJyX2kKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgc3dhcAogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo3MQogICAgLy8gYXNzZXJ0IG1icl9wYXltZW50LmFtb3VudCA+PSBtYnJfZGVsdGFfYW1vdW50LCBlcnIuSU5WQUxJRF9NQlJfQU1PVU5UCiAgICBzd2FwCiAgICBndHhucyBBbW91bnQKICAgIGRpZyAxCiAgICA+PQogICAgYXNzZXJ0IC8vIEludmFsaWQgY2lyY3VsYXRpbmcgc3VwcGx5IGNvbmZpZyBNQlIgYW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjM4CiAgICAvLyBAYWJpbWV0aG9kCiAgICBpdG9iCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmNpcmN1bGF0aW5nX3N1cHBseS5jb250cmFjdC5DaXJjdWxhdGluZ1N1cHBseS5zZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3Nbcm91dGluZ10oKSAtPiB2b2lkOgpzZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3M6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5Ojc1CiAgICAvLyBAYWJpbWV0aG9kCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDMyPgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBpbnRjXzEgLy8gMAogICAgZXh0cmFjdF91aW50MTYgLy8gb24gZXJyb3I6IGludmFsaWQgYXJyYXkgbGVuZ3RoIGhlYWRlcgogICAgcHVzaGludCAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LmR5bmFtaWNfYXJyYXk8YXJjNC51aW50OD4KICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5Ojg4LTg5CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IGFzc2V0Lm1hbmFnZXIsIGVyci5VTkFVVEhPUklaRUQKICAgIHR4biBTZW5kZXIKICAgIGRpZyAzCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0TWFuYWdlcgogICAgYXNzZXJ0IC8vIGFzc2V0IGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBVbmF1dGhvcml6ZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6OTAKICAgIC8vIGFzc2VydCBhc3NldCBpbiBzZWxmLmNpcmN1bGF0aW5nX3N1cHBseSwgZXJyLkNPTkZJR19OT1RfRVhJU1RTCiAgICBkaWcgMgogICAgaXRvYgogICAgZHVwCiAgICBjb3ZlciA0CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBDaXJjdWxhdGluZyBzdXBwbHkgY29uZmlnIGRvZXMgbm90IGV4aXN0IGZvciB0aGlzIEFTQQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo5MQogICAgLy8gYXNzZXJ0IGFkZHJlc3MuaXNfb3B0ZWRfaW4oYXNzZXQpLCBlcnIuTk9UX09QVEVEX0lOCiAgICBzd2FwCiAgICB1bmNvdmVyIDIKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gQWRkcmVzcyBpcyBub3Qgb3B0ZWQtaW4gdGhlIEFTQQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo5NQogICAgLy8gY2FzZSBjZmcuQlVSTkVEOgogICAgcHVzaGJ5dGVzcyAiYnVybmVkIiAibG9ja2VkIiAiY3VzdG9tIgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo5My0xMDIKICAgIC8vICMgRWZmZWN0cwogICAgLy8gbWF0Y2ggbGFiZWw6CiAgICAvLyAgICAgY2FzZSBjZmcuQlVSTkVEOgogICAgLy8gICAgICAgICBzZWxmLmNpcmN1bGF0aW5nX3N1cHBseVthc3NldF0uYnVybmVkX2FkZHIgPSBhZGRyZXNzCiAgICAvLyAgICAgY2FzZSBjZmcuTE9DS0VEOgogICAgLy8gICAgICAgICBzZWxmLmNpcmN1bGF0aW5nX3N1cHBseVthc3NldF0ubG9ja2VkX2FkZHIgPSBhZGRyZXNzCiAgICAvLyAgICAgY2FzZSBjZmcuQ1VTVE9NOgogICAgLy8gICAgICAgICBzZWxmLmNpcmN1bGF0aW5nX3N1cHBseVthc3NldF0uY3VzdG9tX2FkZHIgPSBhZGRyZXNzCiAgICAvLyAgICAgY2FzZSBfOgogICAgLy8gICAgICAgICBvcC5lcnIoZXJyLklOVkFMSURfTEFCRUwpCiAgICB1bmNvdmVyIDMKICAgIG1hdGNoIHNldF9ub3RfY2lyY3VsYXRpbmdfYWRkcmVzc19zd2l0Y2hfY2FzZV8wQDIgc2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzX3N3aXRjaF9jYXNlXzFAMyBzZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3Nfc3dpdGNoX2Nhc2VfMkA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjEwMgogICAgLy8gb3AuZXJyKGVyci5JTlZBTElEX0xBQkVMKQogICAgZXJyIC8vIEludmFsaWQgbGFiZWwKCnNldF9ub3RfY2lyY3VsYXRpbmdfYWRkcmVzc19zd2l0Y2hfY2FzZV8yQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjEwMAogICAgLy8gc2VsZi5jaXJjdWxhdGluZ19zdXBwbHlbYXNzZXRdLmN1c3RvbV9hZGRyID0gYWRkcmVzcwogICAgZHVwCiAgICBwdXNoaW50IDY0CiAgICBkaWcgMwogICAgYm94X3JlcGxhY2UKCnNldF9ub3RfY2lyY3VsYXRpbmdfYWRkcmVzc19zd2l0Y2hfY2FzZV9uZXh0QDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5Ojc1CiAgICAvLyBAYWJpbWV0aG9kCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgpzZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3Nfc3dpdGNoX2Nhc2VfMUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo5OAogICAgLy8gc2VsZi5jaXJjdWxhdGluZ19zdXBwbHlbYXNzZXRdLmxvY2tlZF9hZGRyID0gYWRkcmVzcwogICAgZHVwCiAgICBpbnRjXzMgLy8gMzIKICAgIGRpZyAzCiAgICBib3hfcmVwbGFjZQogICAgYiBzZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3Nfc3dpdGNoX2Nhc2VfbmV4dEA2CgpzZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3Nfc3dpdGNoX2Nhc2VfMEAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo5NgogICAgLy8gc2VsZi5jaXJjdWxhdGluZ19zdXBwbHlbYXNzZXRdLmJ1cm5lZF9hZGRyID0gYWRkcmVzcwogICAgZHVwCiAgICBpbnRjXzEgLy8gMAogICAgZGlnIDMKICAgIGJveF9yZXBsYWNlCiAgICBiIHNldF9ub3RfY2lyY3VsYXRpbmdfYWRkcmVzc19zd2l0Y2hfY2FzZV9uZXh0QDYKCgovLyBzbWFydF9jb250cmFjdHMuY2lyY3VsYXRpbmdfc3VwcGx5LmNvbnRyYWN0LkNpcmN1bGF0aW5nU3VwcGx5LmRlbGV0ZV9jb25maWdbcm91dGluZ10oKSAtPiB2b2lkOgpkZWxldGVfY29uZmlnOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMDQKICAgIC8vIEBhYmltZXRob2QKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC51aW50NjQKICAgIGJ0b2kKICAgIGR1cG4gMgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTYtMTE3CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIGFzc2VydCBhc3NldCBpbiBzZWxmLmNpcmN1bGF0aW5nX3N1cHBseSwgZXJyLkNPTkZJR19OT1RfRVhJU1RTCiAgICBpdG9iCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIENpcmN1bGF0aW5nIHN1cHBseSBjb25maWcgZG9lcyBub3QgZXhpc3QgZm9yIHRoaXMgQVNBCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjI2CiAgICAvLyBfY3JlYXRvciwgZXhpc3RzID0gb3AuQXNzZXRQYXJhbXNHZXQuYXNzZXRfY3JlYXRvcihhc2EpCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0Q3JlYXRvcgogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjExOAogICAgLy8gaWYgX2FzYV9leGlzdHMoYXNzZXQpOgogICAgYnogZGVsZXRlX2NvbmZpZ19hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTE5CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBhc3NldC5tYW5hZ2VyLCBlcnIuVU5BVVRIT1JJWkVECiAgICB0eG4gU2VuZGVyCiAgICBkaWcgMgogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldE1hbmFnZXIKICAgIGFzc2VydCAvLyBhc3NldCBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gVW5hdXRob3JpemVkCgpkZWxldGVfY29uZmlnX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTIxLTEyMgogICAgLy8gIyBEZWxldGUgQVNBIENpcmN1bGF0aW5nIFN1cHBseSBDb25maWd1cmF0aW9uCiAgICAvLyBtYnJfaSA9IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMjMKICAgIC8vIGRlbCBzZWxmLmNpcmN1bGF0aW5nX3N1cHBseVthc3NldF0KICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTI0CiAgICAvLyBtYnJfZGVsdGFfYW1vdW50ID0gbWJyX2kgLSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTI2LTEyNwogICAgLy8gIyBSZWZ1bmQgTUJSCiAgICAvLyBpdHhuLlBheW1lbnQocmVjZWl2ZXI9VHhuLnNlbmRlciwgYW1vdW50PW1icl9kZWx0YV9hbW91bnQpLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICB0eG4gU2VuZGVyCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGludGNfMCAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMSAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTA0CiAgICAvLyBAYWJpbWV0aG9kCiAgICBpdG9iCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmNpcmN1bGF0aW5nX3N1cHBseS5jb250cmFjdC5DaXJjdWxhdGluZ1N1cHBseS5nZXRfY29uZmlnW3JvdXRpbmddKCkgLT4gdm9pZDoKZ2V0X2NvbmZpZzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTMxCiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjE0MgogICAgLy8gYXNzZXJ0IGFzc2V0IGluIHNlbGYuY2lyY3VsYXRpbmdfc3VwcGx5LCBlcnIuQ09ORklHX05PVF9FWElTVFMKICAgIGl0b2IKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gQ2lyY3VsYXRpbmcgc3VwcGx5IGNvbmZpZyBkb2VzIG5vdCBleGlzdCBmb3IgdGhpcyBBU0EKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTQzCiAgICAvLyByZXR1cm4gc2VsZi5jaXJjdWxhdGluZ19zdXBwbHlbYXNzZXRdCiAgICBib3hfZ2V0CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTMxCiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmNpcmN1bGF0aW5nX3N1cHBseS5jb250cmFjdC5DaXJjdWxhdGluZ1N1cHBseS5hcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5W3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseToKICAgIGludGNfMSAvLyAwCiAgICBkdXBuIDIKICAgIHB1c2hieXRlcyAiIgogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjE0NQogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjE1OC0xNTkKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gYXNzZXJ0IGFzc2V0IGluIHNlbGYuY2lyY3VsYXRpbmdfc3VwcGx5LCBlcnIuQ09ORklHX05PVF9FWElTVFMKICAgIGl0b2IKICAgIGR1cAogICAgY292ZXIgMgogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gQ2lyY3VsYXRpbmcgc3VwcGx5IGNvbmZpZyBkb2VzIG5vdCBleGlzdCBmb3IgdGhpcyBBU0EKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MjYKICAgIC8vIF9jcmVhdG9yLCBleGlzdHMgPSBvcC5Bc3NldFBhcmFtc0dldC5hc3NldF9jcmVhdG9yKGFzYSkKICAgIGR1cAogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldENyZWF0b3IKICAgIGNvdmVyIDIKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxNjYKICAgIC8vIGlmIGFzc2V0LnJlc2VydmUgPT0gR2xvYmFsLnplcm9fYWRkcmVzcwogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldFJlc2VydmUKICAgIGFzc2VydCAvLyBhc3NldCBleGlzdHMKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTY2LTE2OAogICAgLy8gaWYgYXNzZXQucmVzZXJ2ZSA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICAvLyBvciBub3QgYXNhX2V4aXN0cwogICAgLy8gb3Igbm90IGFzc2V0LnJlc2VydmUuaXNfb3B0ZWRfaW4oYXNzZXQpCiAgICBibnogYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X3RydWVANAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxNjcKICAgIC8vIG9yIG5vdCBhc2FfZXhpc3RzCiAgICBkdXAKICAgIGJ6IGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV90cnVlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTY4CiAgICAvLyBvciBub3QgYXNzZXQucmVzZXJ2ZS5pc19vcHRlZF9pbihhc3NldCkKICAgIGRpZyAyCiAgICBkdXAKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRSZXNlcnZlCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICBzd2FwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYm56IGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9mYWxzZUA1CgphcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfdHJ1ZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxNjUKICAgIC8vIFVJbnQ2NCgwKQogICAgaW50Y18xIC8vIDAKICAgIGJ1cnkgNAoKYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X21lcmdlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjE3MgogICAgLy8gYnVybmVkX2FkZHIgPSBzZWxmLmNpcmN1bGF0aW5nX3N1cHBseVthc3NldF0uYnVybmVkX2FkZHIKICAgIGRpZyAxCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jaXJjdWxhdGluZ19zdXBwbHkgZW50cnkgZXhpc3RzCiAgICBleHRyYWN0IDAgMzIKICAgIGR1cAogICAgYnVyeSAxMAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxNzUKICAgIC8vIGlmIGJ1cm5lZF9hZGRyID09IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTc1LTE3NwogICAgLy8gaWYgYnVybmVkX2FkZHIgPT0gR2xvYmFsLnplcm9fYWRkcmVzcwogICAgLy8gb3Igbm90IGFzYV9leGlzdHMKICAgIC8vIG9yIG5vdCBidXJuZWRfYWRkci5pc19vcHRlZF9pbihhc3NldCkKICAgIGJueiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfdHJ1ZUA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjE3NgogICAgLy8gb3Igbm90IGFzYV9leGlzdHMKICAgIGR1cAogICAgYnogYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X3RydWVAOQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxNzcKICAgIC8vIG9yIG5vdCBidXJuZWRfYWRkci5pc19vcHRlZF9pbihhc3NldCkKICAgIGRpZyA4CiAgICBkaWcgMwogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBidXJ5IDEKICAgIGJueiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfZmFsc2VAMTAKCmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV90cnVlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjE3NAogICAgLy8gVUludDY0KDApCiAgICBpbnRjXzEgLy8gMAogICAgYnVyeSA2CgphcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfbWVyZ2VAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjE4MQogICAgLy8gbG9ja2VkX2FkZHIgPSBzZWxmLmNpcmN1bGF0aW5nX3N1cHBseVthc3NldF0ubG9ja2VkX2FkZHIKICAgIGRpZyAxCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jaXJjdWxhdGluZ19zdXBwbHkgZW50cnkgZXhpc3RzCiAgICBleHRyYWN0IDMyIDMyCiAgICBkdXAKICAgIGJ1cnkgOAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxODQKICAgIC8vIGlmIGxvY2tlZF9hZGRyID09IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTg0LTE4NgogICAgLy8gaWYgbG9ja2VkX2FkZHIgPT0gR2xvYmFsLnplcm9fYWRkcmVzcwogICAgLy8gb3Igbm90IGFzYV9leGlzdHMKICAgIC8vIG9yIG5vdCBsb2NrZWRfYWRkci5pc19vcHRlZF9pbihhc3NldCkKICAgIGJueiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfdHJ1ZUAxNAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxODUKICAgIC8vIG9yIG5vdCBhc2FfZXhpc3RzCiAgICBkdXAKICAgIGJ6IGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV90cnVlQDE0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjE4NgogICAgLy8gb3Igbm90IGxvY2tlZF9hZGRyLmlzX29wdGVkX2luKGFzc2V0KQogICAgZGlnIDYKICAgIGRpZyAzCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYm56IGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9mYWxzZUAxNQoKYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X3RydWVAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjE4MwogICAgLy8gVUludDY0KDApCiAgICBpbnRjXzEgLy8gMAogICAgYnVyeSA1CgphcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfbWVyZ2VAMTY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjE5MAogICAgLy8gY3VzdG9tX2FkZHIgPSBzZWxmLmNpcmN1bGF0aW5nX3N1cHBseVthc3NldF0uY3VzdG9tX2FkZHIKICAgIGRpZyAxCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jaXJjdWxhdGluZ19zdXBwbHkgZW50cnkgZXhpc3RzCiAgICBleHRyYWN0IDY0IDMyCiAgICBkdXAKICAgIGJ1cnkgOQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxOTMKICAgIC8vIGlmIGN1c3RvbV9hZGRyID09IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTkzLTE5NQogICAgLy8gaWYgY3VzdG9tX2FkZHIgPT0gR2xvYmFsLnplcm9fYWRkcmVzcwogICAgLy8gb3Igbm90IGFzYV9leGlzdHMKICAgIC8vIG9yIG5vdCBjdXN0b21fYWRkci5pc19vcHRlZF9pbihhc3NldCkKICAgIGJueiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfdHJ1ZUAxOQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxOTQKICAgIC8vIG9yIG5vdCBhc2FfZXhpc3RzCiAgICBkdXAKICAgIGJ6IGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV90cnVlQDE5CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjE5NQogICAgLy8gb3Igbm90IGN1c3RvbV9hZGRyLmlzX29wdGVkX2luKGFzc2V0KQogICAgZGlnIDcKICAgIGRpZyAzCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYm56IGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9mYWxzZUAyMAoKYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X3RydWVAMTk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjE5MgogICAgLy8gVUludDY0KDApCiAgICBpbnRjXzEgLy8gMAoKYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X21lcmdlQDIxOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToyMDAKICAgIC8vIGFzc2V0LnRvdGFsCiAgICBkaWcgMwogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldFRvdGFsCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjIwMC0yMDEKICAgIC8vIGFzc2V0LnRvdGFsCiAgICAvLyAtIHJlc2VydmVfYmFsYW5jZQogICAgZGlnIDUKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MjAwLTIwMgogICAgLy8gYXNzZXQudG90YWwKICAgIC8vIC0gcmVzZXJ2ZV9iYWxhbmNlCiAgICAvLyAtIGJ1cm5lZF9iYWxhbmNlCiAgICBkaWcgNwogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToyMDAtMjAzCiAgICAvLyBhc3NldC50b3RhbAogICAgLy8gLSByZXNlcnZlX2JhbGFuY2UKICAgIC8vIC0gYnVybmVkX2JhbGFuY2UKICAgIC8vIC0gbG9ja2VkX2JhbGFuY2UKICAgIGRpZyA2CiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjIwMC0yMDQKICAgIC8vIGFzc2V0LnRvdGFsCiAgICAvLyAtIHJlc2VydmVfYmFsYW5jZQogICAgLy8gLSBidXJuZWRfYmFsYW5jZQogICAgLy8gLSBsb2NrZWRfYmFsYW5jZQogICAgLy8gLSBjdXN0b21fYmFsYW5jZQogICAgc3dhcAogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxNDUKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGl0b2IKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9mYWxzZUAyMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTk2CiAgICAvLyBlbHNlIGFzc2V0LmJhbGFuY2UoY3VzdG9tX2FkZHIpCiAgICBkaWcgNwogICAgZGlnIDMKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgb3B0ZWQgaW50byBhc3NldAogICAgYiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfbWVyZ2VAMjEKCmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9mYWxzZUAxNToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTg3CiAgICAvLyBlbHNlIGFzc2V0LmJhbGFuY2UobG9ja2VkX2FkZHIpCiAgICBkaWcgNgogICAgZGlnIDMKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgb3B0ZWQgaW50byBhc3NldAogICAgYnVyeSA1CiAgICBiIGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9tZXJnZUAxNgoKYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X2ZhbHNlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxNzgKICAgIC8vIGVsc2UgYXNzZXQuYmFsYW5jZShidXJuZWRfYWRkcikKICAgIGRpZyA4CiAgICBkaWcgMwogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBvcHRlZCBpbnRvIGFzc2V0CiAgICBidXJ5IDYKICAgIGIgYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X21lcmdlQDExCgphcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfZmFsc2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTY5CiAgICAvLyBlbHNlIGFzc2V0LmJhbGFuY2UoYXNzZXQucmVzZXJ2ZSkKICAgIGRpZyAyCiAgICBkdXAKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRSZXNlcnZlCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICBzd2FwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgIGJ1cnkgNAogICAgYiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfbWVyZ2VANgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jaXJjdWxhdGluZ19zdXBwbHkuY29udHJhY3QuQ2lyY3VsYXRpbmdTdXBwbHkud2l0aGRyYXdfYmFsYW5jZV9leGNlc3Nbcm91dGluZ10oKSAtPiB2b2lkOgp3aXRoZHJhd19iYWxhbmNlX2V4Y2VzczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MjIzCiAgICAvLyBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmJhbGFuY2UKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToyMjQKICAgIC8vIC0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjIyMy0yMjQKICAgIC8vIEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MuYmFsYW5jZQogICAgLy8gLSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjIyNi0yMjkKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1HbG9iYWwuY3JlYXRvcl9hZGRyZXNzLAogICAgLy8gICAgIGFtb3VudD1leGNlc3NfYmFsYW5jZSwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MjI3CiAgICAvLyByZWNlaXZlcj1HbG9iYWwuY3JlYXRvcl9hZGRyZXNzLAogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToyMjYKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludGNfMCAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMSAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToyMjYtMjI5CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9R2xvYmFsLmNyZWF0b3JfYWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ9ZXhjZXNzX2JhbGFuY2UsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToyMTQKICAgIC8vIEBhYmltZXRob2QKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4K", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMQogICAgcmV0dXJuCg=="}, "sourceInfo": {"approval": {"pcOffsetMethod": "none", "sourceInfo": [{"pc": [257], "errorMessage": "Address is not opted-in the ASA"}, {"pc": [128], "errorMessage": "Circulating supply config already exists for this ASA"}, {"pc": [249, 334, 403, 437], "errorMessage": "Circulating supply config does not exist for this ASA"}, {"pc": [186], "errorMessage": "Invalid circulating supply config MBR amount"}, {"pc": [136], "errorMessage": "Invalid circulating supply config MBR receiver"}, {"pc": [291], "errorMessage": "Invalid label"}, {"pc": [120, 239, 350], "errorMessage": "Unauthorized"}, {"pc": [141, 177, 355, 364, 650, 655], "errorMessage": "account funded"}, {"pc": [603, 613, 625, 640], "errorMessage": "account opted into asset"}, {"pc": [118, 237, 348, 446, 462, 578, 636], "errorMessage": "asset exists"}, {"pc": [477, 511, 545], "errorMessage": "check self.circulating_supply entry exists"}, {"pc": [219], "errorMessage": "invalid array length header"}, {"pc": [227], "errorMessage": "invalid number of bytes for arc4.dynamic_array<arc4.uint8>"}, {"pc": [213], "errorMessage": "invalid number of bytes for arc4.static_array<arc4.uint8, 32>"}, {"pc": [100, 201, 323, 396, 426], "errorMessage": "invalid number of bytes for arc4.uint64"}, {"pc": [111], "errorMessage": "transaction type is pay"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True)
class CirculatingSupplyConfig:
    """Struct for CirculatingSupplyConfig"""
    burned_addr: str
    locked_addr: str
    custom_addr: str


@dataclasses.dataclass(frozen=True, kw_only=True)
class InitConfigArgs:
    """Dataclass for init_config arguments"""
    asset: int
    mbr_payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "init_config(uint64,pay)uint64"

@dataclasses.dataclass(frozen=True, kw_only=True)
class SetNotCirculatingAddressArgs:
    """Dataclass for set_not_circulating_address arguments"""
    asset: int
    address: str
    label: str

    @property
    def abi_method_signature(self) -> str:
        return "set_not_circulating_address(uint64,address,string)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class DeleteConfigArgs:
    """Dataclass for delete_config arguments"""
    asset: int

    @property
    def abi_method_signature(self) -> str:
        return "delete_config(uint64)uint64"

@dataclasses.dataclass(frozen=True, kw_only=True)
class GetConfigArgs:
    """Dataclass for get_config arguments"""
    asset: int

    @property
    def abi_method_signature(self) -> str:
        return "get_config(uint64)(address,address,address)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc62GetCirculatingSupplyArgs:
    """Dataclass for arc62_get_circulating_supply arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc62_get_circulating_supply(uint64)uint64"


class CirculatingSupplyParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def init_config(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | InitConfigArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "init_config(uint64,pay)uint64",
            "args": method_args,
        }))

    def set_not_circulating_address(
        self,
        args: tuple[int, str, str] | SetNotCirculatingAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "set_not_circulating_address(uint64,address,string)void",
            "args": method_args,
        }))

    def delete_config(
        self,
        args: tuple[int] | DeleteConfigArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "delete_config(uint64)uint64",
            "args": method_args,
        }))

    def get_config(
        self,
        args: tuple[int] | GetConfigArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_config(uint64)(address,address,address)",
            "args": method_args,
        }))

    def arc62_get_circulating_supply(
        self,
        args: tuple[int] | Arc62GetCirculatingSupplyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc62_get_circulating_supply(uint64)uint64",
            "args": method_args,
        }))

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "extra_resources()void",
        }))

    def withdraw_balance_excess(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "withdraw_balance_excess()void",
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class CirculatingSupplyCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def init_config(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | InitConfigArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "init_config(uint64,pay)uint64",
            "args": method_args,
        }))

    def set_not_circulating_address(
        self,
        args: tuple[int, str, str] | SetNotCirculatingAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "set_not_circulating_address(uint64,address,string)void",
            "args": method_args,
        }))

    def delete_config(
        self,
        args: tuple[int] | DeleteConfigArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "delete_config(uint64)uint64",
            "args": method_args,
        }))

    def get_config(
        self,
        args: tuple[int] | GetConfigArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_config(uint64)(address,address,address)",
            "args": method_args,
        }))

    def arc62_get_circulating_supply(
        self,
        args: tuple[int] | Arc62GetCirculatingSupplyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc62_get_circulating_supply(uint64)uint64",
            "args": method_args,
        }))

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "extra_resources()void",
        }))

    def withdraw_balance_excess(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "withdraw_balance_excess()void",
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class CirculatingSupplySend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def init_config(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | InitConfigArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "init_config(uint64,pay)uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def set_not_circulating_address(
        self,
        args: tuple[int, str, str] | SetNotCirculatingAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "set_not_circulating_address(uint64,address,string)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def delete_config(
        self,
        args: tuple[int] | DeleteConfigArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "delete_config(uint64)uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def get_config(
        self,
        args: tuple[int] | GetConfigArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[CirculatingSupplyConfig]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_config(uint64)(address,address,address)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(CirculatingSupplyConfig, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[CirculatingSupplyConfig], parsed_response)

    def arc62_get_circulating_supply(
        self,
        args: tuple[int] | Arc62GetCirculatingSupplyArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc62_get_circulating_supply(uint64)uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "extra_resources()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def withdraw_balance_excess(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "withdraw_balance_excess()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class CirculatingSupplyState:
    """Methods to access state for the current CirculatingSupply app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def box(
        self
    ) -> "_BoxState":
            """Methods to access box for the current app"""
            return _BoxState(self.app_client)

class _BoxState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {
            "CirculatingSupplyConfig": CirculatingSupplyConfig
        }

    def get_all(self) -> dict[str, typing.Any]:
        """Get all current keyed values from box state"""
        result = self.app_client.state.box.get_all()
        if not result:
            return {}

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.box.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return converted

    @property
    def circulating_supply(self) -> "_MapState[int, CirculatingSupplyConfig]":
        """Get values from the circulating_supply map in box state"""
        return _MapState(
            self.app_client.state.box,
            "circulating_supply",
            self._struct_classes.get("CirculatingSupplyConfig")
        )

_KeyType = typing.TypeVar("_KeyType")
_ValueType = typing.TypeVar("_ValueType")

class _AppClientStateMethodsProtocol(typing.Protocol):
    def get_map(self, map_name: str) -> dict[typing.Any, typing.Any]:
        ...
    def get_map_value(self, map_name: str, key: typing.Any) -> typing.Any | None:
        ...

class _MapState(typing.Generic[_KeyType, _ValueType]):
    """Generic class for accessing state maps with strongly typed keys and values"""

    def __init__(self, state_accessor: _AppClientStateMethodsProtocol, map_name: str,
                struct_class: typing.Type[_ValueType] | None = None):
        self._state_accessor = state_accessor
        self._map_name = map_name
        self._struct_class = struct_class

    def get_map(self) -> dict[_KeyType, _ValueType]:
        """Get all current values in the map"""
        result = self._state_accessor.get_map(self._map_name)
        if self._struct_class and result:
            return {k: _init_dataclass(self._struct_class, v) if isinstance(v, dict) else v
                    for k, v in result.items()}  # type: ignore
        return typing.cast(dict[_KeyType, _ValueType], result or {})

    def get_value(self, key: _KeyType) -> _ValueType | None:
        """Get a value from the map by key"""
        key_value = dataclasses.asdict(key) if dataclasses.is_dataclass(key) else key  # type: ignore
        value = self._state_accessor.get_map_value(self._map_name, key_value)
        if value is not None and self._struct_class and isinstance(value, dict):
            return _init_dataclass(self._struct_class, value)  # type: ignore
        return typing.cast(_ValueType | None, value)


class CirculatingSupplyClient:
    """Client for interacting with CirculatingSupply smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = CirculatingSupplyParams(self.app_client)
        self.create_transaction = CirculatingSupplyCreateTransactionParams(self.app_client)
        self.send = CirculatingSupplySend(self.app_client)
        self.state = CirculatingSupplyState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "CirculatingSupplyClient":
        return CirculatingSupplyClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "CirculatingSupplyClient":
        return CirculatingSupplyClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "CirculatingSupplyClient":
        return CirculatingSupplyClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "CirculatingSupplyComposer":
        return CirculatingSupplyComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["init_config(uint64,pay)uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["set_not_circulating_address(uint64,address,string)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["delete_config(uint64)uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_config(uint64)(address,address,address)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> CirculatingSupplyConfig | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc62_get_circulating_supply(uint64)uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["extra_resources()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["withdraw_balance_excess()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | CirculatingSupplyConfig | None | int:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class CirculatingSupplyBareCallCreateParams(algokit_utils.AppClientBareCallCreateParams):
    """Parameters for creating CirculatingSupply contract with bare calls"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientBareCallCreateParams:
        return algokit_utils.AppClientBareCallCreateParams(**self.__dict__)

class CirculatingSupplyFactory(algokit_utils.TypedAppFactoryProtocol[CirculatingSupplyBareCallCreateParams, None, None]):
    """Factory for deploying and managing CirculatingSupplyClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = CirculatingSupplyFactoryParams(self.app_factory)
        self.create_transaction = CirculatingSupplyFactoryCreateTransaction(self.app_factory)
        self.send = CirculatingSupplyFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: CirculatingSupplyBareCallCreateParams | None = None,
        update_params: None = None,
        delete_params: None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[CirculatingSupplyClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return CirculatingSupplyClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> CirculatingSupplyClient:
        """Get an app client by creator address and name"""
        return CirculatingSupplyClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> CirculatingSupplyClient:
        """Get an app client by app ID"""
        return CirculatingSupplyClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class CirculatingSupplyFactoryParams:
    """Parameters for creating transactions for CirculatingSupply contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = CirculatingSupplyFactoryCreateParams(app_factory)
        self.update = CirculatingSupplyFactoryUpdateParams(app_factory)
        self.delete = CirculatingSupplyFactoryDeleteParams(app_factory)

class CirculatingSupplyFactoryCreateParams:
    """Parameters for 'create' operations of CirculatingSupply contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def init_config(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | InitConfigArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the init_config(uint64,pay)uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "init_config(uint64,pay)uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def set_not_circulating_address(
        self,
        args: tuple[int, str, str] | SetNotCirculatingAddressArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the set_not_circulating_address(uint64,address,string)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "set_not_circulating_address(uint64,address,string)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def delete_config(
        self,
        args: tuple[int] | DeleteConfigArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the delete_config(uint64)uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "delete_config(uint64)uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def get_config(
        self,
        args: tuple[int] | GetConfigArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_config(uint64)(address,address,address) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_config(uint64)(address,address,address)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc62_get_circulating_supply(
        self,
        args: tuple[int] | Arc62GetCirculatingSupplyArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc62_get_circulating_supply(uint64)uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc62_get_circulating_supply(uint64)uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def extra_resources(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the extra_resources()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "extra_resources()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def withdraw_balance_excess(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the withdraw_balance_excess()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "withdraw_balance_excess()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

class CirculatingSupplyFactoryUpdateParams:
    """Parameters for 'update' operations of CirculatingSupply contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class CirculatingSupplyFactoryDeleteParams:
    """Parameters for 'delete' operations of CirculatingSupply contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class CirculatingSupplyFactoryCreateTransaction:
    """Create transactions for CirculatingSupply contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = CirculatingSupplyFactoryCreateTransactionCreate(app_factory)


class CirculatingSupplyFactoryCreateTransactionCreate:
    """Create new instances of CirculatingSupply contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class CirculatingSupplyFactorySend:
    """Send calls to CirculatingSupply contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = CirculatingSupplyFactorySendCreate(app_factory)


class CirculatingSupplyFactorySendCreate:
    """Send create calls to CirculatingSupply contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[CirculatingSupplyClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return CirculatingSupplyClient(result[0]), result[1]


class CirculatingSupplyComposer:
    """Composer for creating transaction groups for CirculatingSupply contract calls"""

    def __init__(self, client: "CirculatingSupplyClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    def init_config(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | InitConfigArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CirculatingSupplyComposer":
        self._composer.add_app_call_method_call(
            self.client.params.init_config(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "init_config(uint64,pay)uint64", v
            )
        )
        return self

    def set_not_circulating_address(
        self,
        args: tuple[int, str, str] | SetNotCirculatingAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CirculatingSupplyComposer":
        self._composer.add_app_call_method_call(
            self.client.params.set_not_circulating_address(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "set_not_circulating_address(uint64,address,string)void", v
            )
        )
        return self

    def delete_config(
        self,
        args: tuple[int] | DeleteConfigArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CirculatingSupplyComposer":
        self._composer.add_app_call_method_call(
            self.client.params.delete_config(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "delete_config(uint64)uint64", v
            )
        )
        return self

    def get_config(
        self,
        args: tuple[int] | GetConfigArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CirculatingSupplyComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_config(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_config(uint64)(address,address,address)", v
            )
        )
        return self

    def arc62_get_circulating_supply(
        self,
        args: tuple[int] | Arc62GetCirculatingSupplyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CirculatingSupplyComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc62_get_circulating_supply(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc62_get_circulating_supply(uint64)uint64", v
            )
        )
        return self

    def extra_resources(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CirculatingSupplyComposer":
        self._composer.add_app_call_method_call(
            self.client.params.extra_resources(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "extra_resources()void", v
            )
        )
        return self

    def withdraw_balance_excess(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CirculatingSupplyComposer":
        self._composer.add_app_call_method_call(
            self.client.params.withdraw_balance_excess(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "withdraw_balance_excess()void", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "CirculatingSupplyComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "CirculatingSupplyComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)
