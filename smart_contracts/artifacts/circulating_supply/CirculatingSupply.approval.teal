#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 0 8 32
    bytecblock 0x151f7c75 TMPL_ARC54_BURN_ADDRESS
    // smart_contracts/circulating_supply/contract.py:38
    // class CirculatingSupply(Arc62Interface):
    txn NumAppArgs
    bz main___algopy_default_create@16
    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    pushbytess 0x08deee7e 0xa83f2989 0x4cb6d3dc 0xa34795cc 0x5cc2c535 0x0056d9c1 0xb92e267a // method "init_config(uint64,pay)uint64", method "set_not_circulating_address(uint64,address,string)void", method "delete_config(uint64)uint64", method "get_config(uint64)(address,address,address)", method "arc62_get_circulating_supply(uint64)uint64", method "extra_resources()void", method "withdraw_balance_excess()void"
    txna ApplicationArgs 0
    match init_config set_not_circulating_address delete_config get_config arc62_get_circulating_supply main_extra_resources_route@11 withdraw_balance_excess
    err

main_extra_resources_route@11:
    // smart_contracts/circulating_supply/contract.py:219
    // @abimethod
    intc_0 // 1
    return

main___algopy_default_create@16:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return


// smart_contracts.circulating_supply.contract.CirculatingSupply.init_config[routing]() -> void:
init_config:
    // smart_contracts/circulating_supply/contract.py:46
    // @abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/circulating_supply/contract.py:61
    // Txn.sender == asset.manager
    txn Sender
    dig 2
    asset_params_get AssetManager
    assert // asset exists
    ==
    // smart_contracts/circulating_supply/contract.py:59-62
    // # Preconditions
    // assert (
    //     Txn.sender == asset.manager
    // ), err.UNAUTHORIZED  # Implicit ASA existence check
    assert // Unauthorized
    // smart_contracts/circulating_supply/contract.py:63
    // assert asset not in self.circulating_supply, err.CONFIG_EXISTS
    swap
    itob
    dup
    box_len
    bury 1
    !
    assert // Circulating supply config already exists for this ASA
    // smart_contracts/circulating_supply/contract.py:65
    // mbr_payment.receiver == Global.current_application_address
    dig 1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/circulating_supply/contract.py:64-66
    // assert (
    //     mbr_payment.receiver == Global.current_application_address
    // ), err.INVALID_MBR_RECEIVER
    assert // Invalid circulating supply config MBR receiver
    // smart_contracts/circulating_supply/contract.py:68-69
    // # Initialize ASA Circulating Supply Configuration
    // mbr_i = Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/circulating_supply/contract.py:70-72
    // _exists = self.circulating_supply.box(asset).create(
    //     size=size_of(CirculatingSupplyConfig)
    // )
    dig 1
    // smart_contracts/circulating_supply/contract.py:71
    // size=size_of(CirculatingSupplyConfig)
    pushint 96
    // smart_contracts/circulating_supply/contract.py:70-72
    // _exists = self.circulating_supply.box(asset).create(
    //     size=size_of(CirculatingSupplyConfig)
    // )
    box_create
    pop
    // smart_contracts/circulating_supply/contract.py:73
    // self.circulating_supply[asset].burned_addr = Global.zero_address
    global ZeroAddress
    dig 2
    intc_1 // 0
    uncover 2
    box_replace
    // smart_contracts/circulating_supply/contract.py:74
    // self.circulating_supply[asset].locked_addr = Global.zero_address
    global ZeroAddress
    dig 2
    intc_3 // 32
    uncover 2
    box_replace
    // smart_contracts/circulating_supply/contract.py:75
    // self.circulating_supply[asset].custom_addr = Global.zero_address
    global ZeroAddress
    uncover 2
    pushint 64
    uncover 2
    box_replace
    // smart_contracts/circulating_supply/contract.py:77-78
    // # Postconditions
    // mbr_delta_amount = Global.current_application_address.min_balance - mbr_i
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    swap
    -
    // smart_contracts/circulating_supply/contract.py:79
    // assert mbr_payment.amount >= mbr_delta_amount, err.INVALID_MBR_AMOUNT
    swap
    gtxns Amount
    dig 1
    >=
    assert // Invalid circulating supply config MBR amount
    // smart_contracts/circulating_supply/contract.py:46
    // @abimethod
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.circulating_supply.contract.CirculatingSupply.set_not_circulating_address[routing]() -> void:
set_not_circulating_address:
    intc_1 // 0
    // smart_contracts/circulating_supply/contract.py:83
    // @abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 3
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/circulating_supply/contract.py:96-97
    // # Preconditions
    // assert Txn.sender == asset.manager, err.UNAUTHORIZED
    txn Sender
    dig 3
    asset_params_get AssetManager
    assert // asset exists
    ==
    assert // Unauthorized
    // smart_contracts/circulating_supply/contract.py:98
    // assert asset in self.circulating_supply, err.CONFIG_NOT_EXISTS
    dig 2
    itob
    dup
    cover 4
    box_len
    bury 1
    assert // Circulating supply config does not exist for this ASA
    // smart_contracts/circulating_supply/contract.py:99
    // assert address.is_opted_in(asset), err.NOT_OPTED_IN
    swap
    uncover 2
    asset_holding_get AssetBalance
    bury 1
    assert // Address is not opted-in the ASA
    // smart_contracts/circulating_supply/contract.py:103
    // case String(cfg.BURNED):  # FIXME: puyapy bug requires explicit String()
    pushbytess "burned" "locked" "custom"
    // smart_contracts/circulating_supply/contract.py:101-114
    // # Effects
    // match label:
    //     case String(cfg.BURNED):  # FIXME: puyapy bug requires explicit String()
    //         assert _is_arc54_compliant(asset), err.ASA_NOT_ARC54_COMPLIANT
    //         assert address == TemplateVar[Account](
    //             ARC54_BURN_ADDRESS
    //         ), err.INVALID_BURNING_ADDRESS
    //         self.circulating_supply[asset].burned_addr = address
    //     case cfg.LOCKED:
    //         self.circulating_supply[asset].locked_addr = address
    //     case cfg.CUSTOM:
    //         self.circulating_supply[asset].custom_addr = address
    //     case _:
    //         op.err(err.INVALID_LABEL)
    uncover 3
    match set_not_circulating_address_switch_case_0@2 set_not_circulating_address_switch_case_1@3 set_not_circulating_address_switch_case_2@4
    // smart_contracts/circulating_supply/contract.py:114
    // op.err(err.INVALID_LABEL)
    err // Invalid label

set_not_circulating_address_switch_case_2@4:
    // smart_contracts/circulating_supply/contract.py:112
    // self.circulating_supply[asset].custom_addr = address
    dup
    pushint 64
    dig 3
    box_replace

set_not_circulating_address_switch_case_next@6:
    // smart_contracts/circulating_supply/contract.py:83
    // @abimethod
    intc_0 // 1
    return

set_not_circulating_address_switch_case_1@3:
    // smart_contracts/circulating_supply/contract.py:110
    // self.circulating_supply[asset].locked_addr = address
    dup
    intc_3 // 32
    dig 3
    box_replace
    b set_not_circulating_address_switch_case_next@6

set_not_circulating_address_switch_case_0@2:
    // smart_contracts/circulating_supply/contract.py:34
    // clawback, exists = op.AssetParamsGet.asset_clawback(asa)
    dig 2
    asset_params_get AssetClawback
    swap
    bury 5
    // smart_contracts/circulating_supply/contract.py:35
    // return exists and clawback == Global.zero_address
    bz set_not_circulating_address_bool_false@10
    dig 3
    global ZeroAddress
    ==
    bz set_not_circulating_address_bool_false@10
    intc_0 // 1

set_not_circulating_address_bool_merge@11:
    // smart_contracts/circulating_supply/contract.py:104
    // assert _is_arc54_compliant(asset), err.ASA_NOT_ARC54_COMPLIANT
    assert // The ASA must not have a clawback address
    // smart_contracts/circulating_supply/contract.py:105-107
    // assert address == TemplateVar[Account](
    //     ARC54_BURN_ADDRESS
    // ), err.INVALID_BURNING_ADDRESS
    dig 1
    dup
    bytec_1 // TMPL_ARC54_BURN_ADDRESS
    ==
    assert // Invalid ARC-54 burning address
    // smart_contracts/circulating_supply/contract.py:108
    // self.circulating_supply[asset].burned_addr = address
    dig 1
    intc_1 // 0
    uncover 2
    box_replace
    b set_not_circulating_address_switch_case_next@6

set_not_circulating_address_bool_false@10:
    intc_1 // 0
    b set_not_circulating_address_bool_merge@11


// smart_contracts.circulating_supply.contract.CirculatingSupply.delete_config[routing]() -> void:
delete_config:
    // smart_contracts/circulating_supply/contract.py:116
    // @abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dupn 2
    // smart_contracts/circulating_supply/contract.py:128-129
    // # Preconditions
    // assert asset in self.circulating_supply, err.CONFIG_NOT_EXISTS
    itob
    dup
    cover 2
    box_len
    bury 1
    assert // Circulating supply config does not exist for this ASA
    // smart_contracts/circulating_supply/contract.py:28
    // _creator, exists = op.AssetParamsGet.asset_creator(asa)
    asset_params_get AssetCreator
    bury 1
    // smart_contracts/circulating_supply/contract.py:130
    // if _asa_exists(asset):
    bz delete_config_after_if_else@3
    // smart_contracts/circulating_supply/contract.py:131
    // assert Txn.sender == asset.manager, err.UNAUTHORIZED
    txn Sender
    dig 2
    asset_params_get AssetManager
    assert // asset exists
    ==
    assert // Unauthorized

delete_config_after_if_else@3:
    // smart_contracts/circulating_supply/contract.py:133-134
    // # Delete ASA Circulating Supply Configuration
    // mbr_i = Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/circulating_supply/contract.py:135
    // del self.circulating_supply[asset]
    dig 1
    box_del
    pop
    // smart_contracts/circulating_supply/contract.py:136
    // mbr_delta_amount = mbr_i - Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    -
    // smart_contracts/circulating_supply/contract.py:138-139
    // # Refund MBR
    // itxn.Payment(receiver=Txn.sender, amount=mbr_delta_amount).submit()
    itxn_begin
    txn Sender
    dig 1
    itxn_field Amount
    itxn_field Receiver
    intc_0 // pay
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/circulating_supply/contract.py:116
    // @abimethod
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.circulating_supply.contract.CirculatingSupply.get_config[routing]() -> void:
get_config:
    // smart_contracts/circulating_supply/contract.py:143
    // @abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/circulating_supply/contract.py:154
    // assert asset in self.circulating_supply, err.CONFIG_NOT_EXISTS
    itob
    dup
    box_len
    bury 1
    assert // Circulating supply config does not exist for this ASA
    // smart_contracts/circulating_supply/contract.py:155
    // return self.circulating_supply[asset]
    box_get
    pop
    // smart_contracts/circulating_supply/contract.py:143
    // @abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.circulating_supply.contract.CirculatingSupply.arc62_get_circulating_supply[routing]() -> void:
arc62_get_circulating_supply:
    intc_1 // 0
    dupn 2
    pushbytes ""
    dupn 2
    // smart_contracts/circulating_supply/contract.py:157
    // @abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dupn 2
    // smart_contracts/circulating_supply/contract.py:170-171
    // # Preconditions
    // assert asset in self.circulating_supply, err.CONFIG_NOT_EXISTS
    itob
    dup
    cover 2
    box_len
    bury 1
    assert // Circulating supply config does not exist for this ASA
    // smart_contracts/circulating_supply/contract.py:28
    // _creator, exists = op.AssetParamsGet.asset_creator(asa)
    dup
    asset_params_get AssetCreator
    cover 2
    pop
    // smart_contracts/circulating_supply/contract.py:178
    // if asset.reserve == Global.zero_address
    asset_params_get AssetReserve
    assert // asset exists
    global ZeroAddress
    ==
    // smart_contracts/circulating_supply/contract.py:178-180
    // if asset.reserve == Global.zero_address
    // or not asa_exists
    // or not asset.reserve.is_opted_in(asset)
    bnz arc62_get_circulating_supply_ternary_true@4
    // smart_contracts/circulating_supply/contract.py:179
    // or not asa_exists
    dup
    bz arc62_get_circulating_supply_ternary_true@4
    // smart_contracts/circulating_supply/contract.py:180
    // or not asset.reserve.is_opted_in(asset)
    dig 2
    dup
    asset_params_get AssetReserve
    assert // asset exists
    swap
    asset_holding_get AssetBalance
    bury 1
    bnz arc62_get_circulating_supply_ternary_false@5

arc62_get_circulating_supply_ternary_true@4:
    // smart_contracts/circulating_supply/contract.py:177
    // UInt64(0)
    intc_1 // 0
    bury 4

arc62_get_circulating_supply_ternary_merge@6:
    // smart_contracts/circulating_supply/contract.py:184
    // burned_addr = self.circulating_supply[asset].burned_addr
    dig 1
    box_get
    assert // check self.circulating_supply entry exists
    extract 0 32
    dup
    bury 10
    // smart_contracts/circulating_supply/contract.py:187
    // if burned_addr == Global.zero_address
    global ZeroAddress
    ==
    // smart_contracts/circulating_supply/contract.py:187-189
    // if burned_addr == Global.zero_address
    // or not asa_exists
    // or not burned_addr.is_opted_in(asset)
    bnz arc62_get_circulating_supply_ternary_true@9
    // smart_contracts/circulating_supply/contract.py:188
    // or not asa_exists
    dup
    bz arc62_get_circulating_supply_ternary_true@9
    // smart_contracts/circulating_supply/contract.py:189
    // or not burned_addr.is_opted_in(asset)
    dig 8
    dig 3
    asset_holding_get AssetBalance
    bury 1
    bnz arc62_get_circulating_supply_ternary_false@10

arc62_get_circulating_supply_ternary_true@9:
    // smart_contracts/circulating_supply/contract.py:186
    // UInt64(0)
    intc_1 // 0
    bury 6

arc62_get_circulating_supply_ternary_merge@11:
    // smart_contracts/circulating_supply/contract.py:193
    // locked_addr = self.circulating_supply[asset].locked_addr
    dig 1
    box_get
    assert // check self.circulating_supply entry exists
    extract 32 32
    dup
    bury 8
    // smart_contracts/circulating_supply/contract.py:196
    // if locked_addr == Global.zero_address
    global ZeroAddress
    ==
    // smart_contracts/circulating_supply/contract.py:196-198
    // if locked_addr == Global.zero_address
    // or not asa_exists
    // or not locked_addr.is_opted_in(asset)
    bnz arc62_get_circulating_supply_ternary_true@14
    // smart_contracts/circulating_supply/contract.py:197
    // or not asa_exists
    dup
    bz arc62_get_circulating_supply_ternary_true@14
    // smart_contracts/circulating_supply/contract.py:198
    // or not locked_addr.is_opted_in(asset)
    dig 6
    dig 3
    asset_holding_get AssetBalance
    bury 1
    bnz arc62_get_circulating_supply_ternary_false@15

arc62_get_circulating_supply_ternary_true@14:
    // smart_contracts/circulating_supply/contract.py:195
    // UInt64(0)
    intc_1 // 0
    bury 5

arc62_get_circulating_supply_ternary_merge@16:
    // smart_contracts/circulating_supply/contract.py:202
    // custom_addr = self.circulating_supply[asset].custom_addr
    dig 1
    box_get
    assert // check self.circulating_supply entry exists
    extract 64 32
    dup
    bury 9
    // smart_contracts/circulating_supply/contract.py:205
    // if custom_addr == Global.zero_address
    global ZeroAddress
    ==
    // smart_contracts/circulating_supply/contract.py:205-207
    // if custom_addr == Global.zero_address
    // or not asa_exists
    // or not custom_addr.is_opted_in(asset)
    bnz arc62_get_circulating_supply_ternary_true@19
    // smart_contracts/circulating_supply/contract.py:206
    // or not asa_exists
    dup
    bz arc62_get_circulating_supply_ternary_true@19
    // smart_contracts/circulating_supply/contract.py:207
    // or not custom_addr.is_opted_in(asset)
    dig 7
    dig 3
    asset_holding_get AssetBalance
    bury 1
    bnz arc62_get_circulating_supply_ternary_false@20

arc62_get_circulating_supply_ternary_true@19:
    // smart_contracts/circulating_supply/contract.py:204
    // UInt64(0)
    intc_1 // 0

arc62_get_circulating_supply_ternary_merge@21:
    // smart_contracts/circulating_supply/contract.py:212
    // asset.total
    dig 3
    asset_params_get AssetTotal
    assert // asset exists
    // smart_contracts/circulating_supply/contract.py:212-213
    // asset.total
    // - reserve_balance
    dig 5
    -
    // smart_contracts/circulating_supply/contract.py:212-214
    // asset.total
    // - reserve_balance
    // - burned_balance
    dig 7
    -
    // smart_contracts/circulating_supply/contract.py:212-215
    // asset.total
    // - reserve_balance
    // - burned_balance
    // - locked_balance
    dig 6
    -
    // smart_contracts/circulating_supply/contract.py:212-216
    // asset.total
    // - reserve_balance
    // - burned_balance
    // - locked_balance
    // - custom_balance
    swap
    -
    // smart_contracts/circulating_supply/contract.py:157
    // @abimethod(readonly=True)
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

arc62_get_circulating_supply_ternary_false@20:
    // smart_contracts/circulating_supply/contract.py:208
    // else asset.balance(custom_addr)
    dig 7
    dig 3
    asset_holding_get AssetBalance
    assert // account opted into asset
    b arc62_get_circulating_supply_ternary_merge@21

arc62_get_circulating_supply_ternary_false@15:
    // smart_contracts/circulating_supply/contract.py:199
    // else asset.balance(locked_addr)
    dig 6
    dig 3
    asset_holding_get AssetBalance
    assert // account opted into asset
    bury 5
    b arc62_get_circulating_supply_ternary_merge@16

arc62_get_circulating_supply_ternary_false@10:
    // smart_contracts/circulating_supply/contract.py:190
    // else asset.balance(burned_addr)
    dig 8
    dig 3
    asset_holding_get AssetBalance
    assert // account opted into asset
    bury 6
    b arc62_get_circulating_supply_ternary_merge@11

arc62_get_circulating_supply_ternary_false@5:
    // smart_contracts/circulating_supply/contract.py:181
    // else asset.balance(asset.reserve)
    dig 2
    dup
    asset_params_get AssetReserve
    assert // asset exists
    swap
    asset_holding_get AssetBalance
    assert // account opted into asset
    bury 4
    b arc62_get_circulating_supply_ternary_merge@6


// smart_contracts.circulating_supply.contract.CirculatingSupply.withdraw_balance_excess[routing]() -> void:
withdraw_balance_excess:
    // smart_contracts/circulating_supply/contract.py:235
    // Global.current_application_address.balance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/circulating_supply/contract.py:236
    // - Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/circulating_supply/contract.py:235-236
    // Global.current_application_address.balance
    // - Global.current_application_address.min_balance
    -
    // smart_contracts/circulating_supply/contract.py:238-241
    // itxn.Payment(
    //     receiver=Global.creator_address,
    //     amount=excess_balance,
    // ).submit()
    itxn_begin
    // smart_contracts/circulating_supply/contract.py:239
    // receiver=Global.creator_address,
    global CreatorAddress
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/circulating_supply/contract.py:238
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/circulating_supply/contract.py:238-241
    // itxn.Payment(
    //     receiver=Global.creator_address,
    //     amount=excess_balance,
    // ).submit()
    itxn_submit
    // smart_contracts/circulating_supply/contract.py:226
    // @abimethod
    intc_0 // 1
    return
